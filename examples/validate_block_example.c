#include "bitcoinkernel.h"

#include <stdio.h>
#include <stdlib.h>

void handle_error(void* _, const char* msg, size_t msg_size)
{
    printf("%s\n", msg);
    exit(0);
}

void block_checked(void* _, const kernel_BlockPointer* block, const kernel_BlockValidationState* state)
{
    printf("Checked block\n");
}

int main() {
    kernel_ContextOptions* context_options = kernel_context_options_create();
    kernel_NotificationInterfaceCallbacks notifications = {
        .user_data = NULL,
        .block_tip = NULL,
        .header_tip = NULL,
        .progress = NULL,
        .warning_set = NULL,
        .warning_unset = NULL,
        .flush_error = handle_error,
        .fatal_error = handle_error,
    };
    kernel_context_options_set_notifications(context_options, notifications);
    kernel_ValidationInterfaceCallbacks validation_interface = {
        .user_data = NULL,
        .block_checked = block_checked,
    };
    kernel_context_options_set_validation_interface(context_options, validation_interface);
    const kernel_ChainParameters* chainparams = kernel_chain_parameters_create(kernel_CHAIN_TYPE_REGTEST);
    kernel_context_options_set_chainparams(context_options, chainparams);
    kernel_chain_parameters_destroy(chainparams);
    kernel_Context* context = kernel_context_create(context_options);
    kernel_context_options_destroy(context_options);
    if (context == NULL) return 1;

    const char data_dir[] = ".bitcoin";
    const char blocks_dir[] = ".bitcoin/blocks";
    kernel_ChainstateManagerOptions* chainman_options = kernel_chainstate_manager_options_create(context, data_dir, sizeof(data_dir) - 1, blocks_dir, sizeof(blocks_dir) - 1);
    if (chainman_options == NULL) return 1;
    kernel_ChainstateManager* chainman = kernel_chainstate_manager_create(context, chainman_options);
    if (chainman == NULL) return 1;
    kernel_chainstate_manager_options_destroy(chainman_options);

    static const unsigned char block_data[] = {
        0x00, 0x00, 0x00, 0x20, 0x06, 0x22, 0x6e, 0x46, 0x11, 0x1a, 0x0b, 0x59, 0xca, 0xaf, 0x12, 0x60,
        0x43, 0xeb, 0x5b, 0xbf, 0x28, 0xc3, 0x4f, 0x3a, 0x5e, 0x33, 0x2a, 0x1f, 0xc7, 0xb2, 0xb7, 0x3c,
        0xf1, 0x88, 0x91, 0x0f, 0x29, 0x5b, 0xad, 0xc0, 0xbd, 0xd9, 0xa2, 0xbc, 0x09, 0x55, 0xd1, 0x2f,
        0x33, 0x74, 0x91, 0xea, 0xe4, 0xc8, 0x7b, 0xa4, 0x66, 0x00, 0x78, 0xc0, 0x15, 0x63, 0x10, 0x28,
        0x4d, 0x47, 0xc6, 0xff, 0x9a, 0x24, 0x2d, 0x66, 0xff, 0xff, 0x7f, 0x20, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0x51, 0x00, 0xff,
        0xff, 0xff, 0xff, 0x02, 0x00, 0xf2, 0x05, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x14, 0x14,
        0x09, 0x74, 0x54, 0x05, 0xc4, 0xe8, 0x31, 0x0a, 0x87, 0x5b, 0xcd, 0x60, 0x2d, 0xb6, 0xb9, 0xb3,
        0xdc, 0x0c, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x6a, 0x24, 0xaa, 0x21,
        0xa9, 0xed, 0xe2, 0xf6, 0x1c, 0x3f, 0x71, 0xd1, 0xde, 0xfd, 0x3f, 0xa9, 0x99, 0xdf, 0xa3, 0x69,
        0x53, 0x75, 0x5c, 0x69, 0x06, 0x89, 0x79, 0x99, 0x62, 0xb4, 0x8b, 0xeb, 0xd8, 0x36, 0x97, 0x4e,
        0x8c, 0xf9, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    kernel_Block* block = kernel_block_create(block_data, sizeof(block_data));
    if (block == NULL) return 1;

    bool new_block = true;
    int res = kernel_chainstate_manager_process_block(context, chainman, block, &new_block);

    kernel_block_destroy(block);
    kernel_chainstate_manager_destroy(chainman, context);
    kernel_context_destroy(context);
    return !(res && new_block);
}
